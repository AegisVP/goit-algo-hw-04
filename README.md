# goit-algo-hw-04

## Завдання

Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

## Висновки
Для сортування були взяти 3 набори данних: 100 (small data), 1_000 (medium data) та 10_000 (large data) цілих чисел, згенерованих випадково та в випадковій послідовності.

Час виконання сортування кожного з наборів данних різними сортувальними методами приведений в таблиці нижче

| Algorithm          | Time (s) small data  | Time (s) medium data | Time (s) large data 
:------------------- | :------------------- | :------------------- | :-------------------
| Insertion sort     | 0.00781              | 0.71919              | 61.04401            
| Merge sort         | 0.01008              | 0.07422              | 0.64490             
| sorted function    | 0.00008              | 0.00290              | 0.02281             
| .sort method       | 0.00007              | 0.00138              | 0.03138             

Як видно з данних вище, найефективніший тип сортування для малого та середнього обʼєму данних є метод .sort(). Але для великих обʼємів данних він програє вбудованій функції sorted(). Втім різниця на малих обʼємах даних настільки мала, що немає сенсу використовувати метод .sort()